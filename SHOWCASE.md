# ðŸŽ¤ Showcase Script: WASI Python Host

> **The Question:** Why use WebAssembly for IoT?
> **The Answer:** It solves the "Secure Plugin" problem.

This demo proves you can run untrusted Python code on a device with bare-metal access (GPIO), yet keep it **completely sandboxed** and **hot-swappable**.

---

## ðŸš€ The Elevator Pitch
"I have built a **secure plugin system** for IoT devices. It allows developers to write easy Python code to control hardware, but the system is managed by a high-performance Rust host that enforces security and stability."

**Key Features:**
1.  **Polyglot**: Rust (System) + Python (Scripting).
2.  **Sandboxed**: The Python code *cannot* hack the device; it can only request what the Rust host explicitly allows.
3.  **Hot Reload**: Update the Python logic *instantly* without restarting the Rust server.

---

## ðŸ› ï¸ The Demo Flow

### 1. Show the Architecture (WIT File)
Open `wit/plugin.wit`. This is the "Constitution".
*   **Explain**: "This file defines the contract. The Python code imports `gpio-provider`. If I don't give it that import, the Python code simply cannot touch the hardware. It's physically impossible."

### 2. Show the Running Dashboard
Open **http://rasperry-pi-ip:3000**.
*   **Explain**: "This dashboard is HTML generated by Python running inside WebAssembly. The data comes from a real DHT22 sensor read by the Rust host."

### 3. Demonstrate Hot Reload (The "Magic Trick")
1.  Open `plugins/dashboard/app.py`.
2.  Change the title color or text (e.g., change "WASI Python Dashboard" to "LIVE DEMO MODE").
3.  Run the build command on the Pi:
    ```bash
    # On the Pi:
    cd ~/wasi-python-host/plugins/dashboard
    ~/.local/bin/componentize-py -d ../../wit -w dashboard-plugin componentize app -o dashboard.wasm
    ```
4.  **Do NOT restart the Rust host.**
5.  Refresh the browser.
6.  **Bam!** The change is live.
*   **Explain**: "I just updated the application logic without stopping the server or dropping connections. This is how serverless platforms work."

### 4. Explain the "Why" 
If you just wanted to read a sensor, a 5-line Python script is fine.
**But this architecture allows you to:**
*   Allow *other people* to write plugins for your device.
*   Isolate crashy code (if Python crashes, the Rust host stays up - as seen with our sensor timeout fix!).
*   Update individual components over-the-air without full system reboots.

---

## ðŸ”Œ Hardware Setup
*   **Raspberry Pi 3/4/5**
*   **DHT22 Sensor**:
    *   **VCC (Pin 1)** -> 3.3V (Physical Pin 1)
    *   **Data (Pin 2)** -> GPIO4 (Physical Pin 7)
    *   **GND (Pin 4)** -> Ground (Physical Pin 6)
    *   **Pull-up Resistor**: 4.7kÎ© between VCC and Data (often built-in to modules).
