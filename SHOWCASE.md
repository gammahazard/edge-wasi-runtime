# ðŸŽ¤ Showcase Script: WASI Python Host

> **The Question:** Why use WebAssembly for IoT?
> **The Answer:** It solves the "Secure Plugin" problem.

This demo proves you can run untrusted Python code on a device with bare-metal access (GPIO), yet keep it **completely sandboxed** and **hot-swappable**.

---

## ðŸš€ What is this?
I have built a **secure plugin system** for IoT devices. It allows developers to write easy Python code to control hardware, but the system is managed by a high-performance Rust host that enforces security and stability.

**Key Features:**
1.  **Polyglot**: Rust (System) + Python (Scripting).
2.  **Sandboxed**: The Python code *cannot* hack the device; it can only request what the Rust host explicitly allows.
3.  **Hot Reload**: Update the Python logic *instantly* without restarting the Rust server.

---

## ðŸ› ï¸ The Demo Flow

### 1. The Constitution (`wit/plugin.wit`)
Open `wit/plugin.wit`. This is where we define the rules.
*   **Talking Point**: The Python code imports `gpio-provider`. Without this explicit import, the sandbox physically prevents access to the hardware. It's deny-by-default.

### 2. The Dashboard
Open **http://raspberry-pi-ip:3000**.
*   **Talking Point**: This HTML is generated by Python running inside WebAssembly. The data is real, coming from the Rust host reading the DHT22 sensor.

### 3. Hot Reload (The Magic Trick)
1.  Open `plugins/dashboard/app.py`.
2.  Change the title color or text (e.g., "LIVE DEMO MODE").
3.  Run the build command on the Pi.
4.  **Do NOT restart the Rust host.**
5.  Refresh the browser.
*   **Talking Point**: I just updated the application logic without stopping the server. No dropped connections. This is how modern serverless platforms work.

### 4. Why This Matters
If you just wanted to read a sensor, a 5-line Python script is fine.
**But this architecture allows you to:**
*   Isolate crashy code (if Python crashes, the Rust host stays up).
*   Update individual components over-the-air without full system reboots.
*   Securely run code from third parties (plugins).

---

## ðŸ”Œ Hardware Setup
*   **Raspberry Pi 3/4/5**
*   **DHT22 Sensor**:
    *   **VCC (Pin 1)** -> 3.3V (Physical Pin 1)
    *   **Data (Pin 2)** -> GPIO4 (Physical Pin 7)
    *   **GND (Pin 4)** -> Ground (Physical Pin 6)
    *   **Pull-up Resistor**: 4.7kÎ© between VCC and Data (often built-in to modules).
