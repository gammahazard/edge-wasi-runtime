# ðŸŽ¤ Showcase Script: WASI Python Host

> **The Question:** Why use WebAssembly for IoT?
> **The Answer:** It solves the "Secure Plugin" problem AND enables distributed monitoring.

This demo proves you can run untrusted Python code on devices with bare-metal access (GPIO), yet keep it **completely sandboxed**, **hot-swappable**, and **distributed across multiple nodes**.

---

## ðŸš€ What is this?

A **secure plugin system** for IoT devices with **Hub/Spoke clustering**. Developers write easy Python code to control hardware, managed by a high-performance Rust host that enforces security and aggregates data from multiple nodes.

**Key Features:**
1.  **Polyglot**: Rust (System) + Python (Scripting).
2.  **Sandboxed**: Python code *cannot* hack the device; it can only request what the Rust host explicitly allows.
3.  **Hot Reload**: Update Python logic *instantly* without restarting the Rust server.
4.  **Distributed**: Hub aggregates sensor data from multiple Spoke nodes.
5.  **Multi-Hardware**: DHT22, BME680, WS2812B LEDs, Piezo Buzzer.

---

## ðŸ› ï¸ The Demo Flow

### 1. The Constitution (`wit/plugin.wit`)
Open `wit/plugin.wit`. This defines the security contract. The Python code imports `gpio-provider`, `led-controller`, and `buzzer-controller`. Without explicit imports, the sandbox physically prevents hardware access. It's deny-by-default.

### 2. The Dashboard
Open **http://192.168.40.9:3000** (Hub IP). This HTML is generated by Python running inside WebAssembly. The data is real, aggregated from the RevPi Hub and Pi 4 Spoke - two separate devices!

### 3. Hub/Spoke Architecture
- **RevPi Hub** (192.168.40.9): Runs the dashboard, aggregates data, no sensors.
- **Pi 4 Spoke** (192.168.40.4): Runs DHT22, BME680, and Pi-Monitor plugins. Pushes data to Hub via `POST /push`.

The Spoke uses `reqwest` to HTTP POST sensor readings every poll cycle. The Hub merges them into shared state.

### 4. LED Status Indicators
Look at the LED strip on the Pi 4 - three LEDs are lit:
- **LED 0**: CPU temperature status (Green/Yellow/Red)
- **LED 1**: Room temperature status (Green/Orange/Red/Blue)
- **LED 2**: Air quality status (Green/Yellow/Red/Purple during calibration)

The Python WASM plugin *cannot* directly control GPIOs. It calls `led_controller.set_led()` which the host implements. This is capability-based security.

### 5. Automatic Alerts
The plugins have built-in alert thresholds:
- **Room temp > 30Â°C**: LED 1 turns RED, buzzer sounds
- **Room temp < 15Â°C**: LED 1 turns BLUE
- **CPU temp > 70Â°C**: LED 0 turns RED
- **IAQ > 200**: LED 2 turns RED

These thresholds live in the Python plugins and can be changed without recompiling the Rust host.

### 6. Manual Dashboard Controls
On the dashboard, you can see **Buzzer Controls**:
1.  Click **"BEEP ONCE"** - Listen for the short beep.
2.  Click **"BEEP 3 TIMES"** - Listen for the pattern.
3.  Click **"LONG BEEP (5s)"** - Listen for the extended beep.

This demonstrates bi-directional communication. The browser sends a POST request to the Rust host (`/api/buzzer`), which triggers the hardware capability.

### 7. Hot Reload (The Magic Trick)
1.  SSH to the Pi 4 Spoke.
2.  Edit `plugins/dht22/app.py`.
3.  Change `HIGH_ALARM = 30.0` to `HIGH_ALARM = 20.0`.
4.  Rebuild: `cd plugins/dht22 && componentize-py -d ../../wit -w dht22-plugin componentize app -o dht22.wasm`
5.  **Do NOT restart the Rust host.**
6.  Wait 5 seconds - LED 1 turns RED and buzzer beeps!

The alert logic was updated without stopping the server. No dropped connections. The thresholds live in the hot-swappable Python module.

---

## ðŸ”Œ Hardware Setup

### Hub (RevPi Connect 4)
- Industrial DIN-rail mounted device
- No sensors attached (aggregator only)
- Monitors its own CPU/RAM via `pi-monitor` plugin

### Spoke (Raspberry Pi 4)
- **DHT22 Temperature/Humidity Sensor**:
    - VCC â†’ 3.3V (Pin 1)
    - Data â†’ GPIO4 (Pin 7)
    - GND â†’ Ground (Pin 6)
    - Pull-up: 4.7kÎ© between VCC and Data
- **BME680 Environmental Sensor** (I2C 0x77):
    - SDA â†’ GPIO 2 (Pin 3)
    - SCL â†’ GPIO 3 (Pin 5)
    - VCC â†’ 3.3V
    - GND â†’ GND
- **WS2812B LED Strip (11 LEDs)**:
    - VCC â†’ 5V (Pin 2)
    - GND â†’ Ground (Pin 14)
    - DIN â†’ GPIO18 (Pin 12)
- **Piezo Buzzer via SainSmart Relay**:
    - Relay VCC â†’ 5V
    - Relay GND â†’ Ground
    - Relay IN â†’ GPIO17 (Pin 11) - **Active LOW**
    - Buzzer connected to relay NO terminals

---

## ðŸ“Š Visual Status Guide

| LED | Device | Color  | Meaning           |
|-----|--------|--------|-------------------|
| 0   | Spoke  | Green  | CPU < 50Â°C        |
| 0   | Spoke  | Yellow | CPU 50-70Â°C       |
| 0   | Spoke  | Red    | CPU > 70Â°C        |
| 1   | Spoke  | Green  | Room temp normal  |
| 1   | Spoke  | Orange | Room 25-30Â°C      |
| 1   | Spoke  | Red    | Room > 30Â°C + Buzzer |
| 1   | Spoke  | Blue   | Room < 15Â°C       |
| 2   | Spoke  | Purple | BME680 Calibrating|
| 2   | Spoke  | Green  | IAQ Excellent (0-50)|
| 2   | Spoke  | Yellow | IAQ Moderate (100-150)|
| 2   | Spoke  | Red    | IAQ Bad (200+)    |
| 3   | Hub    | Green  | Hub CPU < 50Â°C    |
| 3   | Hub    | Yellow | Hub CPU 50-70Â°C   |
| 3   | Hub    | Red    | Hub CPU > 70Â°C    |

---

## ðŸŽ¯ Why This Matters

If you just wanted to read a sensor, a 5-line Python script is fine.
**But this architecture allows you to:**
- Isolate crashy code (if Python crashes, the Rust host stays up).
- Update individual components over-the-air without full system reboots.
- Securely run code from third parties (plugins).
- Add new hardware capabilities without changing plugin code.
- **Aggregate data from multiple devices** into a single dashboard.
