# üé§ Showcase Script: WASI Python Host

> **The Question:** Why use WebAssembly for IoT?
> **The Answer:** It solves the "Secure Plugin" problem.

This demo proves you can run untrusted Python code on a device with bare-metal access (GPIO), yet keep it **completely sandboxed** and **hot-swappable**.

---

## üöÄ What is this?
I have built a **secure plugin system** for IoT devices. It allows developers to write easy Python code to control hardware, but the system is managed by a high-performance Rust host that enforces security and stability.

**Key Features:**
1.  **Polyglot**: Rust (System) + Python (Scripting).
2.  **Sandboxed**: The Python code *cannot* hack the device; it can only request what the Rust host explicitly allows.
3.  **Hot Reload**: Update the Python logic *instantly* without restarting the Rust server.
4.  **Multi-Hardware**: Sensor (DHT22), LEDs (WS2812B), Buzzer (via relay).

---

## üõ†Ô∏è The Demo Flow

### 1. The Constitution (`wit/plugin.wit`)
Open `wit/plugin.wit`. This defines the security contract.
*   **Talking Point**: The Python code imports `gpio-provider`, `led-controller`, and `buzzer-controller`. Without explicit imports, the sandbox physically prevents hardware access. It's deny-by-default.

### 2. The Dashboard
Open **http://raspberry-pi-ip:3000**.
*   **Talking Point**: This HTML is generated by Python running inside WebAssembly. The data is real, coming from the Rust host reading the DHT22 sensor.

### 3. LED Status Indicators
Look at the LED strip - two LEDs are lit:
*   **LED 0 (Yellow/Green/Red)**: CPU temperature status
*   **LED 1 (Green/Red/Blue)**: Room temperature status
*   **Talking Point**: The Python WASM plugin *cannot* directly control GPIOs. It calls `led_controller.set_two()` which the host implements. This is capability-based security.

### 4. Hot Reload (The Magic Trick)
1.  Open `plugins/sensor/app.py`.
2.  Change `TEMP_HIGH = 30.0` to `TEMP_HIGH = 20.0`.
3.  Rebuild the WASM: `componentize-py ...`
4.  **Do NOT restart the Rust host.**
5.  Wait 5 seconds - LED 1 turns RED and buzzer beeps!
*   **Talking Point**: I just updated the alert logic without stopping the server. No dropped connections. The thresholds live in the hot-swappable Python module.

### 5. Why This Matters
If you just wanted to read a sensor, a 5-line Python script is fine.
**But this architecture allows you to:**
*   Isolate crashy code (if Python crashes, the Rust host stays up).
*   Update individual components over-the-air without full system reboots.
*   Securely run code from third parties (plugins).
*   Add new hardware capabilities without changing plugin code.

---

## üîå Hardware Setup
*   **Raspberry Pi 4**
*   **DHT22 Temperature/Humidity Sensor**:
    *   VCC ‚Üí 3.3V (Pin 1)
    *   Data ‚Üí GPIO4 (Pin 7)
    *   GND ‚Üí Ground (Pin 6)
    *   Pull-up: 4.7kŒ© between VCC and Data
*   **WS2812B LED Strip (11 LEDs)**:
    *   VCC ‚Üí 5V (Pin 2)
    *   GND ‚Üí Ground (Pin 14)
    *   DIN ‚Üí GPIO18 (Pin 12)
*   **Buzzer via SainSmart Relay**:
    *   Relay VCC ‚Üí 5V
    *   Relay GND ‚Üí Ground
    *   Relay IN ‚Üí GPIO17 (Pin 11) - **Active LOW**
    *   Buzzer connected to relay NO terminals

---

## üìä Visual Status Guide

| LED | Color  | Meaning           |
|-----|--------|-------------------|
| 0   | Green  | CPU < 50¬∞C        |
| 0   | Yellow | CPU 50-70¬∞C       |
| 0   | Red    | CPU > 70¬∞C        |
| 1   | Green  | Room temp normal  |
| 1   | Red    | Room > 30¬∞C       |
| 1   | Blue   | Room < 15¬∞C       |
| 1   | Cyan   | Humidity > 80%    |

Buzzer sounds on high temp (3 beeps) or high humidity (2 beeps).

