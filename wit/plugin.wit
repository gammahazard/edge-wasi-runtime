// =============================================================================
// plugin.wit - The API Contract
// =============================================================================
//
// WHAT IS THIS?
// This file defines the "Constitution" of our application. It strictly defines
// what the Host (Rust) provides and what the Guest (Python) requires.
//
// WHY IS THIS SECURE?
// 1. Sandboxing: The Python code runs in a WASM sandbox. It CANNOT access
//    files, network, or hardware unless explicitly allowed here.
// 2. Capabilities: The `import` statements are the ONLY capabilities we give.
//    If we don't import `network`, the Python code physically cannot make requests.
// 3. Type Safety: Rust and Python data types are bridged automatically. No
//    more parsing JSON strings or unchecked void pointers.
//
// HOW IT WORKS:
// The `wit-bindgen` and `componentize-py` tools read this file and generate:
// - Rust traits (Host)
// - Python classes (Guest)
// The runtime instantiates the WASM and links these together.

package demo:plugin@0.2.0;

// =============================================================================
// ARCHITECTURE OVERVIEW
// =============================================================================
//
// HOST (Rust) <---> [ Boundary (this file) ] <---> GUEST (Python WASM)
//      |                                                 |
//  [Real Hardware]                                  [Business Logic]
//      |                                                 |
//   DHT22 Sensor                                    Data Processing
//                                                   HTML Rendering
//
// =============================================================================
//
// HOW TO EXTEND THIS (MIGRATION GUIDE):
//
// 1. ADD A CAPABILITY:
//    To add a new hardware feature (e.g., an LED), define it here first:
//    `interface led-controller { func turn-on(); func turn-off(); }`
//    Then implement it in the Rust host (`host/src/runtime.rs`).
//
// 2. MIGRATE LOGIC GRADUALLY:
//    - Start with a monolith Python script.
//    - Identify ONE function (e.g., "calculate_average").
//    - Move it to a `.wit` interface.
//    - Run it in WASM.
//    - Repeat until the legacy script is gone.
//
// 3. WHY DO THIS?
//    Every line of code you move to WASM becomes sandboxed. If it crashes,
//    it doesn't take down the kernel or the host.
//
// =============================================================================

interface gpio-provider {
    // read temperature and humidity from dht22 sensor on given gpio pin
    //
    // @param pin: The BCM GPIO pin number (e.g., 4)
    // @returns: Result containing (temp_c, hum_%) tuple OR error string
    read-dht22: func(pin: u8) -> result<tuple<f32, f32>, string>;
    
    // get current timestamp in milliseconds (unix epoch)
    // used for timestamping readings since WASM has no system clock access by default
    get-timestamp-ms: func() -> u64;
    
    // get raspberry pi cpu temperature in celsius
    // reads from /sys/class/thermal/thermal_zone0/temp
    // useful for monitoring system health and preventing thermal throttling
    get-cpu-temp: func() -> f32;
    
    // [DEPRECATED] read bme680 environmental sensor (i2c)
    // This function will be removed in Phase 4.
    // Use the generic `i2c.transfer()` interface instead.
    //
    // @param i2c-addr: The I2C address (usually 0x76 or 0x77)
    // @returns: Result containing (temp_c, hum_%, pres_hpa, gas_kohm) tuple OR error string
    read-bme680: func(i2c-addr: u8) -> result<tuple<f32, f32, f32, f32>, string>;
}

// =============================================================================
// led-controller - capability for controlling ws2812b led strip
// =============================================================================
//
// hardware: btf lighting ws2812b strip (11 leds) on gpio 18
//
// why this interface?
//     the wasm plugin cannot directly access gpio. instead it calls these
//     functions and the rust host handles the actual hardware control via
//     the rpi_ws281x library (python subprocess).
//
// relationships:
//     - implemented by: host/src/gpio.rs (hardware access)
//     - linked in: host/src/runtime.rs (HostState impl)
//     - called by: plugins/sensor/app.py (alert logic)
//
interface led-controller {
    // set a single led to an rgb color
    //
    // @param index: led position (0-10 for 11 leds)
    // @param r: red component (0-255)
    // @param g: green component (0-255)
    // @param b: blue component (0-255)
    set-led: func(index: u8, r: u8, g: u8, b: u8);
    
    // set all leds to the same rgb color
    //
    // @param r: red component (0-255)
    // @param g: green component (0-255)
    // @param b: blue component (0-255)
    set-all: func(r: u8, g: u8, b: u8);
    
    // set led 0 and led 1 atomically in one call (avoids flicker)
    //
    // @param r0, g0, b0: color for led 0 (cpu temp)
    // @param r1, g1, b1: color for led 1 (room temp)
    set-two: func(r0: u8, g0: u8, b0: u8, r1: u8, g1: u8, b1: u8);
    
    // turn off all leds (set to black)
    clear: func();

    // flush memory buffer to hardware (avoids flicker between plugins)
    sync-leds: func();
}

// =============================================================================
// buzzer-controller - capability for controlling piezo buzzer via relay
// =============================================================================
//
// hardware: cyclewet buzzer connected via sainsmart relay on gpio 17
// note: relay is ACTIVE LOW (gpio low = relay on = buzzer sounds)
//
// why this interface?
//     same as led-controller - wasm cannot access gpio directly.
//     the host handles the active-low relay logic so plugins don't need
//     to know the hardware details.
//
// relationships:
//     - implemented by: host/src/gpio.rs (hardware access)
//     - linked in: host/src/runtime.rs (HostState impl)
//     - called by: plugins/sensor/app.py (alert logic)
//
interface buzzer-controller {
    // sound the buzzer for a duration
    //
    // @param duration-ms: how long to buzz in milliseconds
    buzz: func(duration-ms: u32);
    
    // beep pattern: multiple short beeps with intervals
    //
    // @param count: number of beeps
    // @param duration-ms: length of each beep in milliseconds
    // @param interval-ms: pause between beeps in milliseconds
    beep: func(count: u8, duration-ms: u32, interval-ms: u32);
}

// =============================================================================
// system-info - generic system statistics
// =============================================================================
//
// provides safe access to host metrics like memory usage and cpu load.
// reliable and agnostic to the underlying os (linux/mac/windows).
//
interface system-info {
    // get current memory usage
    // @returns: (used_mb, total_mb)
    get-memory-usage: func() -> tuple<u32, u32>;

    // get current cpu load (average percentage across all cores)
    get-cpu-usage: func() -> f32;

    // get system uptime in seconds
    get-uptime: func() -> u64;
}

// =============================================================================
// GENERIC HAL INTERFACES (Phase 3)
// =============================================================================
//
// These interfaces provide raw hardware access for the "Compile Once" model.
// Instead of sensor-specific functions (read-bme680), plugins use generic
// bus operations (i2c-transfer) and implement the driver logic in Python.
//
// SECURITY NOTE:
// Raw I/O access is powerful. Use permission.toml to restrict which addresses
// each plugin can access.
//

// -----------------------------------------------------------------------------
// i2c - Inter-Integrated Circuit bus
// -----------------------------------------------------------------------------
// Common I2C sensors: BME680, BME280, SHT31, AHT20, OLED (SSD1306), etc.
//
interface i2c {
    // Perform an I2C transfer (write then read)
    //
    // @param addr: 7-bit I2C device address (e.g., 0x77 for BME680)
    // @param write-data: hex-encoded bytes to write (e.g., "D0" for register 0xD0)
    // @param read-len: number of bytes to read back from the device
    // @returns: hex-encoded bytes read from device (e.g., "61" for chip ID)
    //           or error string
    //
    // NOTE: Uses hex strings for BOTH input and output due to componentize-py
    //       marshalling limitations with list<u8>.
    //       Python: i2c.transfer(0x77, "D0", 1) -> "61"
    //       Decode in Python: bytes.fromhex(result)
    //       Encode in Python: bytes([0xD0]).hex()
    //
    transfer: func(addr: u8, write-data: string, read-len: u32) -> result<string, string>;
}

// -----------------------------------------------------------------------------
// spi - Serial Peripheral Interface
// -----------------------------------------------------------------------------
// Common SPI devices: APA102/DotStar LEDs, SD cards, OLED displays, etc.
//
interface spi {
    // Perform a full-duplex SPI transfer
    //
    // @param data: bytes to send to the device
    // @returns: bytes received from device (same length as input)
    //
    transfer: func(data: list<u8>) -> result<list<u8>, string>;
}

// -----------------------------------------------------------------------------
// uart - Universal Asynchronous Receiver/Transmitter
// -----------------------------------------------------------------------------
// Common UART devices: GPS modules, LoRa radios, fingerprint sensors, etc.
//
interface uart {
    // Read bytes from UART buffer
    //
    // @param max-len: maximum number of bytes to read
    // @returns: bytes available in buffer (may be less than max-len)
    //
    read: func(max-len: u32) -> result<list<u8>, string>;
    
    // Write bytes to UART
    //
    // @param data: bytes to send
    // @returns: number of bytes actually written
    //
    write: func(data: list<u8>) -> result<u32, string>;
    
    // Set baud rate
    //
    // @param rate: baud rate (e.g., 9600, 115200)
    //
    set-baud: func(rate: u32) -> result<tuple<>, string>;
}



interface dht22-logic {
    record dht22-reading {
        sensor-id: string,
        temperature: f32,
        humidity: f32,
        timestamp-ms: u64,
    }

    // poll the dht22 sensor and return readings
    // called by the host based on config poll interval
    poll: func() -> list<dht22-reading>;
}

// =============================================================================
// pi-monitor-logic - Raspberry Pi system monitoring
// =============================================================================
//
// purpose:
//     provides system health metrics for the Raspberry Pi host.
//     controls LED 0 to indicate system status.
//
// relationships:
//     - implemented by: plugins/pi-monitor/app.py
//     - loaded by: host/src/runtime.rs
//
interface pi-monitor-logic {
    record pi-stats {
        cpu-temp: f32,
        cpu-usage: f32,
        memory-used-mb: u32,
        memory-total-mb: u32,
        uptime-seconds: u64,
        timestamp-ms: u64,
    }

    // poll pi system stats
    // called by the host based on config poll interval
    poll: func() -> pi-stats;
}

interface bme680-logic {
    record bme680-reading {
        sensor-id: string,
        temperature: f32,
        humidity: f32,
        pressure: f32,
        gas-resistance: f32,
        iaq-score: u16,
        iaq-accuracy: u8,
        timestamp-ms: u64,
    }

    // poll the bme680 sensor
    poll: func() -> list<bme680-reading>;
}

interface dashboard-logic {
    // render a complete html dashboard page with real sensor data
    // called by the host when a browser hits http://host:3000/
    //
    // @param sensor-data: JSON string containing all sensor readings
    //
    // JSON format:
    // {
    //   "dht22": { "temp": 22.5, "humidity": 45.0 },
    //   "bme680": { "temp": 23.0, "humidity": 40.0, "pressure": 1013.25, "gas": 50.0, "iaq": 25 },
    //   "pi": { "cpu_temp": 55.0, "memory_used_mb": 1500, "memory_total_mb": 4000, "uptime_seconds": 12345 },
    //   "oled": { ... },  // Future sensors just add new keys
    // }
    //
    // This allows adding new sensors WITHOUT modifying WIT or recompiling the host!
    //
    render: func(sensor-data: string) -> string;
}

world dht22-plugin {
    import gpio-provider;
    import led-controller;
    import buzzer-controller;
    export dht22-logic;
}

world pi-monitor-plugin {
    import gpio-provider;
    import led-controller;
    import system-info;
    export pi-monitor-logic;
}

world bme680-plugin {
    import gpio-provider;
    import led-controller;
    import i2c;  // Generic I2C for future migration
    export bme680-logic;
}

world dashboard-plugin {
    export dashboard-logic;
}

// =============================================================================
// GENERIC PLUGIN WORLDS (Phase 3)
// =============================================================================
// These worlds allow writing new sensor drivers without Host recompilation.
// Plugins import generic bus interfaces and implement driver logic in Python.
//

world generic-i2c-plugin {
    import i2c;
    import led-controller;
    import system-info;
    import gpio-provider;  // For timestamp-ms, cpu-temp
    export bme680-logic;   // Reuse bme680-logic interface for now
}


interface oled-logic {
    // update the display with the latest sensor data (JSON)
    update: func(sensor-data: string);
}

world oled-plugin {
    import i2c;
    export oled-logic;
}
