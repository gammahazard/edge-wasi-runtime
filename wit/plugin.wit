// =============================================================================
// plugin.wit - The API Contract
// =============================================================================
//
// WHAT IS THIS?
// This file defines the "Constitution" of our application. It strictly defines
// what the Host (Rust) provides and what the Guest (Python) requires.
//
// WHY IS THIS SECURE?
// 1. Sandboxing: The Python code runs in a WASM sandbox. It CANNOT access
//    files, network, or hardware unless explicitly allowed here.
// 2. Capabilities: The `import` statements are the ONLY capabilities we give.
//    If we don't import `network`, the Python code physically cannot make requests.
// 3. Type Safety: Rust and Python data types are bridged automatically. No
//    more parsing JSON strings or unchecked void pointers.
//
// HOW IT WORKS:
// The `wit-bindgen` and `componentize-py` tools read this file and generate:
// - Rust traits (Host)
// - Python classes (Guest)
// The runtime instantiates the WASM and links these together.

package demo:plugin@0.1.0;

// =============================================================================
// ARCHITECTURE OVERVIEW
// =============================================================================
//
// HOST (Rust) <---> [ Boundary (this file) ] <---> GUEST (Python WASM)
//      |                                                 |
//  [Real Hardware]                                  [Business Logic]
//      |                                                 |
//   DHT22 Sensor                                    Data Processing
//                                                   HTML Rendering
//
// =============================================================================
//
// HOW TO EXTEND THIS (MIGRATION GUIDE):
//
// 1. ADD A CAPABILITY:
//    To add a new hardware feature (e.g., an LED), define it here first:
//    `interface led-controller { func turn-on(); func turn-off(); }`
//    Then implement it in the Rust host (`host/src/runtime.rs`).
//
// 2. MIGRATE LOGIC GRADUALLY:
//    - Start with a monolith Python script.
//    - Identify ONE function (e.g., "calculate_average").
//    - Move it to a `.wit` interface.
//    - Run it in WASM.
//    - Repeat until the legacy script is gone.
//
// 3. WHY DO THIS?
//    Every line of code you move to WASM becomes sandboxed. If it crashes,
//    it doesn't take down the kernel or the host.
//
// =============================================================================

interface gpio-provider {
    // read temperature and humidity from dht22 sensor on given gpio pin
    //
    // @param pin: The BCM GPIO pin number (e.g., 4)
    // @returns: Result containing (temp_c, hum_%) tuple OR error string
    read-dht22: func(pin: u8) -> result<tuple<f32, f32>, string>;
    
    // get current timestamp in milliseconds (unix epoch)
    // used for timestamping readings since WASM has no system clock access by default
    get-timestamp-ms: func() -> u64;
    
    // get raspberry pi cpu temperature in celsius
    // reads from /sys/class/thermal/thermal_zone0/temp
    // useful for monitoring system health and preventing thermal throttling
    get-cpu-temp: func() -> f32;
}

// =============================================================================
// led-controller - capability for controlling ws2812b led strip
// =============================================================================
//
// hardware: btf lighting ws2812b strip (11 leds) on gpio 18
//
// why this interface?
//     the wasm plugin cannot directly access gpio. instead it calls these
//     functions and the rust host handles the actual hardware control via
//     the rpi_ws281x library (python subprocess).
//
// relationships:
//     - implemented by: host/src/gpio.rs (hardware access)
//     - linked in: host/src/runtime.rs (HostState impl)
//     - called by: plugins/sensor/app.py (alert logic)
//
interface led-controller {
    // set a single led to an rgb color
    //
    // @param index: led position (0-10 for 11 leds)
    // @param r: red component (0-255)
    // @param g: green component (0-255)
    // @param b: blue component (0-255)
    set-led: func(index: u8, r: u8, g: u8, b: u8);
    
    // set all leds to the same rgb color
    //
    // @param r: red component (0-255)
    // @param g: green component (0-255)
    // @param b: blue component (0-255)
    set-all: func(r: u8, g: u8, b: u8);
    
    // set led 0 and led 1 atomically in one call (avoids flicker)
    //
    // @param r0, g0, b0: color for led 0 (cpu temp)
    // @param r1, g1, b1: color for led 1 (room temp)
    set-two: func(r0: u8, g0: u8, b0: u8, r1: u8, g1: u8, b1: u8);
    
    // turn off all leds (set to black)
    clear: func();
}

// =============================================================================
// buzzer-controller - capability for controlling piezo buzzer via relay
// =============================================================================
//
// hardware: cyclewet buzzer connected via sainsmart relay on gpio 17
// note: relay is ACTIVE LOW (gpio low = relay on = buzzer sounds)
//
// why this interface?
//     same as led-controller - wasm cannot access gpio directly.
//     the host handles the active-low relay logic so plugins don't need
//     to know the hardware details.
//
// relationships:
//     - implemented by: host/src/gpio.rs (hardware access)
//     - linked in: host/src/runtime.rs (HostState impl)
//     - called by: plugins/sensor/app.py (alert logic)
//
interface buzzer-controller {
    // sound the buzzer for a duration
    //
    // @param duration-ms: how long to buzz in milliseconds
    buzz: func(duration-ms: u32);
    
    // beep pattern: multiple short beeps with intervals
    //
    // @param count: number of beeps
    // @param duration-ms: length of each beep in milliseconds
    // @param interval-ms: pause between beeps in milliseconds
    beep: func(count: u8, duration-ms: u32, interval-ms: u32);
}

interface sensor-logic {
    record sensor-reading {
        sensor-id: string,
        temperature: f32,
        humidity: f32,
        timestamp-ms: u64,
    }

    // poll the dht22 sensor and return readings
    // called by the host every 5 seconds
    poll: func() -> list<sensor-reading>;
}

interface dashboard-logic {
    // render a complete html dashboard page with real sensor data
    // called by the host when a browser hits http://host:3000/
    //
    // @param temperature: room temperature in celsius (from dht22)
    // @param humidity: relative humidity percentage (from dht22)
    // @param cpu-temp: raspberry pi cpu temperature in celsius
    render: func(temperature: f32, humidity: f32, cpu-temp: f32) -> string;
}

world sensor-plugin {
    import gpio-provider;
    import led-controller;
    import buzzer-controller;
    export sensor-logic;
}

world dashboard-plugin {
    export dashboard-logic;
}
